from .models import *
import xml.etree.ElementTree as ET
from typing import Optional
from rich.progress import track

ATEXT_SIGLUM = "AText"

def make_nc_name(string):
    invalid_chars = "!\"#$%&'()*+/:;<=>?@[\]^,{|}~` "
    result = str(string).translate(str.maketrans(invalid_chars, '_' * len(invalid_chars)))
    # if result[0].isdigit or result[0] in [".", "-"]:
    #     result = "id-" + result

    return result

def reading_slug(reading):
    slug = make_nc_name(str(reading))
    return f"{reading.id}-{slug}"


def add_relation(transcriptional_relations, active_reading, passive_reading, ana, transcriptional_options):
    ana = make_nc_name(ana)
    transcriptional_options.add(ana)
    return ET.SubElement(
        transcriptional_relations, 
        'relation',
        active=reading_slug(active_reading), # start reading n
        passive=reading_slug(passive_reading),
        ana=f"#{ana}", # the rate, https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-att.global.analytic.html
    )


def write_tei(
    collection, 
    file:Path, 
    witnesses=None, 
    locations=None,
    subyz:bool=True,
    min_locations=1, 
    exclude_sigla=None,
    atext_witness:bool=False,
    atext_certainty_degree:int=5,
):
    if witnesses is None:
        witnesses = collection.witnessess_no_correctors()

    witnesses = [witness for witness in witnesses if witness.locations_attested(collection=collection).count() >= min_locations]
    
    if exclude_sigla:
        witnesses = list(filter( lambda witness : ( str(witness) not in exclude_sigla ), witnesses ))

    if locations is None:
        locations = collection.locations()

    root = ET.Element('TEI', xmlns="http://www.tei-c.org/ns/1.0")
    teiHeader = ET.SubElement(root, 'teiHeader')
    fileDesc = ET.SubElement(teiHeader, 'fileDesc')
    titleStmt = ET.SubElement(fileDesc, 'titleStmt')
    respStmt = ET.SubElement(titleStmt, 'respStmt')
    resp = ET.SubElement(respStmt, 'resp')
    resp.text = "Generated by dcodex."

    publicationStmt = ET.SubElement(fileDesc, 'publicationStmt')
    ET.SubElement(publicationStmt, 'p').text = "Generated by dcodex variants."

    sourceDesc = ET.SubElement(fileDesc, 'sourceDesc')
    ET.SubElement(sourceDesc, 'p').text = "Generated by dcodex variants."

    listWit = ET.SubElement(sourceDesc, 'listWit')

    text_element = ET.SubElement(root, 'text')
    interp_intrinsic = ET.SubElement(text_element, 'interpGrp', type="intrinsic")
    interp = ET.SubElement(interp_intrinsic, 'interp', attrib={"xml:id":"AText"})
    certainty = ET.SubElement(interp, 'certainty', degree=str(atext_certainty_degree))
    interp_transcriptional = ET.SubElement(text_element, 'interpGrp', type="transcriptional")
    transcriptional_options = set()

    body = ET.SubElement(text_element, 'body')

    included_witnesses = set()
    
    for location in track(locations, description="Creating TEI:"):
        location_slug = make_nc_name(location)
        column_xmlid = f"L{location.id}__{location_slug}"
        app = ET.SubElement(body, 'app', attrib={"xml:id": column_xmlid, "loc": str(location)})
        atext_reading = None
        if isinstance(location, LocationUBS):
            atext_reading = location.ausgangstext

        if atext_reading:
            lem = ET.SubElement(app, 'lem')
            lem.text = str(atext_reading)

        for reading in location.reading_set.all():
            attestations = reading.attestation_set.filter(witness__in=witnesses)
            reading_witnesses = [attestation.witness for attestation in attestations]
            sigla = [str(witness) for witness in reading_witnesses]
            witnesses_str = " ".join(sigla)
            if atext_witness and reading == atext_reading:
                witnesses_str = f"{ATEXT_SIGLUM} {witnesses_str}"

            rdg = ET.SubElement(app, 'rdg', wit=witnesses_str, n=reading_slug(reading))
            rdg.text = reading.text

            included_witnesses.update(reading_witnesses)

        note = ET.Element('note')
        atext_reading = getattr(location, 'ausgangstext', None)
        if atext_reading:
            intrinsic_relations = ET.SubElement(note, 'listRelation', type="intrinsic")                
            for reading in location.reading_set.all():
                if reading != atext_reading:
                    relation = ET.SubElement(
                        intrinsic_relations, 
                        'relation',
                        active=reading_slug(atext_reading), # start reading n
                        passive=reading_slug(reading),
                        ana="#AText",
                    )

        # List relation elements
        byz_reading = getattr(location, 'byz', None)
        if subyz and byz_reading:
            transcriptional_relations = ET.SubElement(note, 'listRelation', attrib={"type":"transcriptional"})
            for reading in location.reading_set.exclude(id=byz_reading.id):
                add_relation(transcriptional_relations, reading, byz_reading, "TO_BYZ", transcriptional_options)
                add_relation(transcriptional_relations, byz_reading, reading, "FROM_BYZ", transcriptional_options)

        if len(note):
            app.append(note)

    if atext_witness:
        witness = ET.SubElement(listWit, 'witness', n=ATEXT_SIGLUM)

    for witness in included_witnesses:
        witness_element = ET.SubElement(listWit, 'witness', n=str(witness))

        origin_date_earliest, origin_date_latest = getattr(witness, 'origin_date_earliest', None), getattr(witness, 'origin_date_latest', None)

        if origin_date_earliest is not None:
            if origin_date_earliest == origin_date_latest:
                ET.SubElement(witness_element, 'origDate', when=str(origin_date_earliest))
            else:
                ET.SubElement(witness_element, 'origDate', notBefore=str(origin_date_earliest), notAfter=str(origin_date_latest))
        
    for ana in transcriptional_options:
        ET.SubElement(interp_transcriptional, 'interp', attrib={"xml:id":ana})

    tree = ET.ElementTree(root)
    ET.indent(tree, space="\t", level=0)
    string = ET.tostring(root, encoding="utf-8")

    print(string.decode("utf-8"))

    
    if file:
        to_close_file = False
        if isinstance(file, (str, Path)):
            file = open(file, "w")
            to_close_file = True
            
        file.write(string.decode("utf-8"))

        if to_close_file:
            file.close()

    

